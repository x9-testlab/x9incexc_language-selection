# x9incexc_language-selection

The goal with these four related repositories, is to use a relatively simple project objective (produce a list of filtered files for consumption by programs that provide something like a `--files-from` command-line option), as a testbed to determine which programming language is most suitable for a broader family of more complex future products.

## Pros and cons

| Project | Language | Pros | Cons | Comments |
|:--- |:--- |:--- |:--- |:---
| [x9incexc-bash](https://github.com/x9-testlab/x9incexc-bash) | Bash             | •I (JC) am highly proficient in Bash, even as limited as it is, and have a well-established toolkit. •Tends to be simpler by relying on high-level POSIX tools, and in that way at least, possibly the easiest to develop and maintain. Since almost all heavy lifting is done by finely-tuned POSIX tools, performs really well overall. •Can even use Sqlite3 CLI interface without much fuss, though far better to stick with well-established, long-term API-stable, universally-installed POSIX tools. •There's even at least one good Bash linter now, which is a great help. | •It's Bash, so... •No type safety. •No interactive debugging. •No classes. •No private members. •Per-line interpreted. •Only works in reasonably recent Bash environment (Linux, WSL, OSX with Homebrew or MacPorts). | Bash is great for task automation and proofs-of-concept. Not so much full-blown system tools. |
| [x9incexc-cs](https://github.com/x9-testlab/x9incexc-cs)     | C# (dotnet core) | •I (JC) am reasonably fluent in C#, so it's fairly quick and natural dev effort. •C# performs really well. •Inherently cross-platform. •Can now "compile" to a single executable requiring no runtime. •With the right compile flags, can compile to a single small executable that itself can run on any platform without modification, as long as the correct runtime environment is already installed. | •There's no way to statically link Sqlite3 into an exe - it has to be already installed. (There are kludges that allow packing it in for runtime extraction, but it has to be the right one for the platform, and it's still not statically linked.) •The standard C# ADO-compatible Sqlite3 wrapper is currently broken, when it comes to compiling down to a single exe. •Single executables with runtime are huge, and actually self-extract to a temporary location before running. •Smaller executables that require pre-installed runtimes, are susceptible to almost certain bitrot in the long run. •**Many of these cons are individual deal-breakers for a project of this nature, which needs to be entirely self-contained and resistant to long-term bitrot.** | I (JC) adore C#, especially now with dotnet core. But that doesn't mean it's the right tool for this job. |
| [x9incexc-cpp](https://github.com/x9-testlab/x9incexc-cpp)   | C++ 17           | •The ultimate in small footprint, speed, long-term maintainability, and long-term resistance to bitrot. •Easy to compile and statically link Sqlite3 as part of the build workflow. | What follows here is mostly opinion, but certainly not unique opinion: •Even with C++ 17, the language remains inscrutably arcane, anachronistic, and over-reliant on cryptic combinations of symbols rather than keywords, as syntax. •The investment in time to become an expert is daunting. •No one human - not even Stroustrup - can hold the entire language in one's head. •When even average C++ projects need a committee to decide and enforce what subset of C++ will be used and how, you know there may be a more fundamental problem suggesting that - while a language may be excellent - it may be too complex for human use. •Setting up the toolchain for C++ is always a bear. That should never be, say, 33% of a project effort. What build system? How to organize? What compiler? •Making that toolchain also be seamlessly cross-platform - especially including Windows - is a major headache. | All else being equal, C++ requires too much time fiddling with toolchain, cross-platform issues, mysterious syntax errors and other complexities of the language, and opportunities for leaks and segfaults. It's off the table.


 Same benefits as C# and CPP version (, but smaller, faster, more maintainable over a longer period of time, and has no external dependencies - not even sqlite3.
